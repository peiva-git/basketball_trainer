import argparse
import pathlib

from skimage.io import imread_collection, imsave
from skimage.morphology import white_tophat, remove_small_objects, disk

from paddleseg.utils.progbar import Progbar
from paddleseg.utils import logger
from paddleseg.utils import metrics

import numpy as np
import paddle as pp


def pseudocolor_mask_to_grayscale(mask: np.ndarray) -> np.ndarray:
    mask = np.argmax(mask, axis=-1, keepdims=False)
    mask = mask - 2
    mask = np.absolute(mask)
    return mask


def postprocess_mask(mask: np.ndarray, min_size: int, max_radius: int, filters=('rm-small',)) -> np.ndarray:
    filtered = mask
    if 'rm-small' in filters:
        filtered = remove_small_objects(filtered.astype(bool), min_size=min_size)
    if 'rm-large' in filters:
        filtered = white_tophat(filtered.astype(bool), footprint=disk(radius=max_radius))
    return filtered.astype(np.int64)


def postprocess_labels_dir(source_dir: pathlib.Path,
                           target_dir: pathlib.Path,
                           min_size: int = 625,
                           max_radius: int = 19):
    source_pattern = str(source_dir / '*.png')
    masks = imread_collection(source_pattern)
    for mask_index, mask in enumerate(masks):
        grayscale_mask = pseudocolor_mask_to_grayscale(mask)
        processed_mask = postprocess_mask(grayscale_mask, min_size=min_size, max_radius=max_radius)
        imsave(str(target_dir / f'label{mask_index + 1}.png'), processed_mask, check_contrast=False)


def evaluate_postprocessed_masks(masks_dir: pathlib.Path,
                                 ground_truths_dir: pathlib.Path,
                                 filters,
                                 min_size: int = 625,
                                 max_radius: int = 19) -> (np.ndarray, np.ndarray, np.ndarray, float):
    masks = imread_collection(str(masks_dir / '*.png'))
    ground_truths = imread_collection(str(ground_truths_dir / '*.png'))
    assert len(masks) == len(ground_truths), \
        f'Should have the same number of masks and ground truths, ' \
        f'but got {len(masks)} masks and {len(ground_truths)} ground truths'

    progbar = Progbar(target=len(masks), verbose=1)
    logger.info(f'Start evaluating (total_samples: {len(masks)}')

    intersect_area_all = pp.zeros([1], dtype='int64')
    pred_area_all = pp.zeros([1], dtype='int64')
    label_area_all = pp.zeros([1], dtype='int64')

    for index, (mask, ground_truth) in enumerate(zip(masks, ground_truths)):
        grayscale_mask = pseudocolor_mask_to_grayscale(mask)
        filtered_mask = postprocess_mask(grayscale_mask, min_size=min_size, max_radius=max_radius, filters=filters)
        intersect_area, pred_area, label_area = metrics.calculate_area(
            pp.to_tensor(filtered_mask, dtype='int64'),
            pp.to_tensor(ground_truth, dtype='int64'),
            2,
            ignore_index=255
        )
        intersect_area_all = intersect_area_all + intersect_area
        pred_area_all = pred_area_all + pred_area
        label_area_all = label_area_all + label_area

        progbar.update(index)

    metrics_input = (intersect_area_all, pred_area_all, label_area_all)
    class_iou, _ = metrics.mean_iou(*metrics_input)
    _, class_precision, class_recall = metrics.class_measurement(*metrics_input)
    kappa = metrics.kappa(*metrics_input)

    logger.info(f'Class IoU: {np.round(class_iou, 4)}')
    logger.info(f'Class Precision: {np.round(class_precision, 4)}')
    logger.info(f'Class Recall: {np.round(class_recall, 4)}')
    logger.info(f'Kappa: {kappa:.4f}')

    return class_iou, class_precision, class_recall, kappa


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--masks_dir',
        help='Root directory of the masks generated by the model',
        type=str,
        required=True
    )
    parser.add_argument(
        '--gt_dir',
        help='Root directory of the corresponding ground truths',
        type=str,
        required=True
    )
    parser.add_argument(
        '--min_size',
        help='Objects smaller than this size will be filtered out of the mask',
        type=int,
        required=False,
        default=625  # 25 * 25
    )
    parser.add_argument(
        '--max_radius',
        help="Disks with a larger radius will be filtered out of the mask",
        type=int,
        required=False,
        default=19
    )
    parser.add_argument(
        '--filter',
        help='Which filter to use during post-processing. '
             'Can use multiple filters by specifying this option many times',
        choices=['rm-large', 'rm-small'],
        required=True,
        action='append'
    )
    args = parser.parse_args()
    evaluate_postprocessed_masks(pathlib.Path(args.masks_dir),
                                 pathlib.Path(args.gt_dir),
                                 args.filter,
                                 args.min_size,
                                 args.max_radius)
